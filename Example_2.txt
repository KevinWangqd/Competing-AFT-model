set.seed(12)
n = 1500

sigma1 = 1
alpha1 = 1
beta11 = -3
beta12 = 2
beta14 = 1


sigma2 = 1
alpha2 = 1.5
beta21 = 2
beta22 = 2


sigma3 = 1.1
alpha3 = 1
beta31 = -2
beta32 = 3
beta33 = 2


X1 = rnorm(n)
X2 = rnorm(n)
X3 = rnorm(n)
X4 = rnorm(n)
#X5 = rnorm(n)

X = cbind(X1, X2, X3, X4)

scale1 = exp(X1*beta11 + X2*beta12 + X4*beta14 + alpha1)
scale2 = exp(X1*beta21 + X2*beta22 + alpha2)
scale3 = exp(X1*beta31 + X2*beta32 + X3*beta33 + alpha3)

T1 = rep(NA,n)
T2 = rep(NA,n)
T3 = rep(NA,n)
T = rep(NA,n)

set.seed(12)
for (i in 1:n) {
  T1[i] = rweibull(1,scale=scale1[i], shape = 1/sigma1)
  T2[i] = rweibull(1,scale=scale2[i], shape = 1/sigma2)
  T3[i] = rweibull(1,scale=scale3[i], shape = 1/sigma3)
  T[i] = min(T1[i], T2[i], T3[i])
}


data <- cbind(T1, T2, T3, T)


Y = log(T)

delta = rep(1,n)


label = list(c(1,2,3), c(1,2,3), 3, 1)
### you may run the data_transform(T, delta, X, label) code and then fit this example
## For this example, the fisher information leads to NaN calculation
## here is the result for estimates.

# Print transformed data to check the result
transformed_data = data_transform(Y, delta, X, label)

# with defaul initialization
init_param = param_init(X, label)
init_param


## with initialization
p <- vector("list") 
p$alpha = list(0.1, 1.4, 1.2)
p$beta = list(c(-0.7,0.6,0), c(0.5, 0.5),c(-0.5, 0.7, 0.1))
p$sigma =list(1,1,1.1)
init_param = param_init(X, label, p)
